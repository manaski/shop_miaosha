**并发的瓶颈在于数据库**

微服务框架基于springboot

#  第一章 框架搭建

## Thymeleaf整合

springboot已经自动生成了template文件夹，并且配置好了前缀和后缀的设置

**Thymeleaf是什么？**
简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。
　　特点：
　    1.Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。**浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。**
　　2.Thymeleaf 开箱即用的特性。它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、改jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。

   　　　3.  Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。

## Result结果的封装

主要包括两部分，Result类的定义和封装，状态码的设计

为了在成功时和失败时便于调用，需要提供静态方法直接调用，不用每次都调用构造函数。

```java
@Data
public class Result<T> {
	private int code;
	private String msg;
	private T data;
	//success
	private Result(T data) {
		this.code=0;
		this.msg="success";
		this.data=data;
	}
	//error
	private Result(CodeMsg cm) {
		if(cm==null) {
			return;
		}
		this.code=cm.getCode();
		this.msg=cm.getMsg();
	}
	//成功
	public static <T> Result<T> success(T data){
		return new Result<T>(data) ;
	}
	// 失败
	public static <T> Result<T> error(CodeMsg sm) {//CodeMsg包含了code和msg
		return new Result<T>(sm);
	}
}
```

## 状态码封装

将Code和Message封装成一个对象CodeMsg，便于调用。比如

```java
public class CodeMsg {
	private int code;
	private String msg;
 public static CodeMsg SUCCESS=new CodeMsg(0,"success");//静态内部对象
    public CodeMsg(int code,String msg) {
		this.code=code;
		this.msg=msg;
	}
}
```







### Springboot整合druid遇到的问题

```xml
unable to load authentication_plugin=caching_sha2_password
```

改变连接驱动版本

```xml
  <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.11</version>
        </dependency>
```

### 连接显示时区问题

```xml
The server time zone value 'ÖÐ¹ú±ê×¼Ê±¼ä' is unrecognized or represents more than one time
```

修改连接URL

```xml
jdbc:mysql://localhost:3306/miaosha?serverTimezone=GMT%2B8&useUnicode=true&characterEncoding=utf8&useSSL=false
```

### 连接发生

```xml
validateConnection false
```

解决方法：提高druid版本

```xml
    <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
            <version>1.1.10</version>
        </dependency>
```

## Redis安装

具体教程可以看这个

https://www.jianshu.com/p/79737bc39396

安装完成之后，把Redis安装为系统服务，可以用install-service，可以转为service

/usr/local/redis/redis.conf

/usr/local/redis/log.conf

/usr/local/redis/data

## Redis操作的封装

自己定义Redisservice，调用底层的jedis方法，包括

```java
public T get(KeyPrefix prefix,String key,Class data) 根据key取得缓存中值（根据传入的前缀）
public boolean delete(KeyPrefix prefix,String key) 删除key
public boolean set(KeyPrefix prefix,String key,T value) 根据key设置缓存中值
public Long decr(KeyPrefix prefix,String key) 自减
public Long incr(KeyPrefix prefix,String key)	自增
public boolean exitsKey(KeyPrefix prefix,String key) 是否存在key
public static T stringToBean(String s,Class clazz) 对象和字符串转化
public static String beanToString(T value)
```

主要包括：

Redis配置类和配置文件的关联，采用@ConfigurationProperties(prefix="redis")

设计JedisPoolFactory，用@Bean注解，向容器中添加jedisPool

设计RedisService来封装底层操作

```java
	public <T> T get(KeyPrefix prefix,String key,Class<T> data){
		Jedis jedis=null;
		//在JedisPool里面取得Jedis
		try {
			jedis=jedisPool.getResource();
			//生成真正的key  className+":"+prefix;  BasePrefix:id1
			String realKey=prefix.getPrefix()+key;
			String sval=jedis.get(realKey);
			//将String转换为Bean入后传出
			T t=stringToBean(sval,data);
			return t;
		}finally {
			returnToPool(jedis);   //将链接交还链接池
		}
	}
```

## RedisKey的封装

为什么要这个通用缓存Key？当项目中的模块越来越多的时候，需要存的缓存也越来越多，比如商品Id,订单Id，用户id等,此时若是id出现重复，将给系统带来错误。

**使用KeyPrefix来更好的操作和管理缓存中对应的key。给不同模块的key带有一个前缀。**

BasePrefix 抽象类：简单的实现一下KeyPrefix，定义成抽象类原因，防止不小心被创建，我们不希望BasePrefix被实例化，因为抽象类不允许实例化。我们只希望它被继承。不同模块的前缀类都继承他。**

```java
public abstract class BasePrefix implements KeyPrefix{
	private int expireSeconds;
	private String prefix;//每个模块固定的前缀修饰
	public BasePrefix() {
	}
	public BasePrefix(String prefix) {
		//this(0, prefix);//默认使用0，不会过期
		this.expireSeconds=0;
		this.prefix=prefix;		
	}
	public BasePrefix(int expireSeconds,String prefix) {//覆盖了默认的构造函数
		this.expireSeconds=expireSeconds;
		this.prefix=prefix;
	}
	//默认为0代表永不过期
	public int expireSeconds() {
		return expireSeconds;
	}
	//前缀为类名:+prefix    类名  这样来区分key
	public String getPrefix() {
		String className=getClass().getSimpleName();
		return className+":"+prefix;
	}
}
```

```java
//实现	
public class UserKey extends BasePrefix{
	public UserKey(String prefix) {
		super(prefix);
	}
	public static UserKey getById=new UserKey("id");
	public static UserKey getByName=new UserKey("name");
}
public class MiaoshaUserKey extends BasePrefix{
	public static final int TOKEN_EXPIRE=3600*24*2;//3600S*24*2    =2天
	public MiaoshaUserKey(int expireSeconds,String prefix) {
		super(expireSeconds,prefix);
	}
	public static MiaoshaUserKey token=new MiaoshaUserKey(TOKEN_EXPIRE,"tk");
	//对象缓存一般没有有效期，永久有效
	public static MiaoshaUserKey getById=new MiaoshaUserKey(0,"id");
	}
```



```xml

<!--Redis包中的类和接口-->
KeyPrefix   接口
BasePrefix  抽象类
GoodsKey    实现类
MiaoshaKey
MiaoshaUserKey
OrderKey
UserKey
AccessKey
RedisConfig   读取配置文件
RedisPoolFactory   生成redisPool
RedisService   自定义操作服务

```

**BasePrefix 抽象类：简单的实现一下KeyPrefix，定义成抽象类原因，防止不小心被创建，我们不希望BasePrefix被实例化，因为抽象类不允许实例化。我们只希望它被继承。不同模块的前缀类都继承他。**

**注意：key类2种不同构造方法：用于继承。一个只带前缀名，一个带前缀名和过期时间。当实现public BasePrefix(String prefix)的时候，我们将默认这个key不会失效，因为有一些场景，我们不希望key失效，但是有些场景我们需要设置key的合适的有效期。**

# 登录功能

## 两次MD5

用户端加密是为了避免http明文传输

服务端加密是为了防止数据库被盗之后，数据泄露

第一次MD5的salt定义在前端，固定的值。salt就是一个字符串，在使用时选择某些字符和要加密的字符串进行拼接，然后再进行MD5加密。

这里只是登录，没有注册功能。在注册阶段，在向服务端发送加密后的密码时，再发送一个随机salt，服务端会保存这个随机salt，并利用这个salt做第二次MD5验证。

实际上做MD5也不是绝对安全的，但是我们可以使得**破解的难度指数级增长**。**md5是不可逆的，不能反向解密的，网上所谓的“解密”都是把“加密”结果存储到数据库再比对的只能暴力破解**，即有一个字典，从字典中读取一条记录，将密码用加salt盐值做MD5来对比数据库里面的值是否相等。

```js
$.validator.setDefaults( {
			submitHandler: function () {   //点击提交时执行，发生在表单校验后
				var pass=$("#password").val();
				//pass='111111';
				var salt='1a2b3c4d';    //前端固定的salt
				var str=""+salt.charAt(0)+salt.charAt(2)+pass+salt.charAt(5)+salt.charAt(4);
				var password=md5(str);  //前端MD5
				$.ajax({
					url:"/login/do_login",
					type:"POST",
					data:{
						mobile:$("#phone").val(),
						password:password,
					},    //请求成功或失败的操作，data是返回的值Result对象
					success:function(data){
						if(data.code==0){
							alert("success");
							//成功后跳转
							window.location.href="/goods/to_list";
						}else{
							alert(data.msg);
						}
					},
					error:function(data){
						alert("error");
					}
				});
			}
		} );
```



## 登陆校验

## 前端校验

在页面用jQuery实现表单的校验，可以定义校验的rules和显示的messages

```js
$( document ).ready( function () {
			$( "#signupForm" ).validate( {  //验证表单
				rules: {   //验证规则
					firstname: "required",
					lastname: "required",
					username: {
						required: true,  //是否必填
						minlength: 2     //最小长度
					},
					password: {
						required: true,
						minlength: 5
					},
					confirm_password: {
						required: true,
						minlength: 5,
						equalTo: "#password"
					},
					email: {
						required: true,
						email: true
					},
					agree: "required"
				},
				messages: {
					firstname: "Please enter your firstname",  //提示信息
					lastname: "Please enter your lastname",
					username: {
						required: "Please enter a username",
						minlength: "Your username must consist of at least 2 characters"
					},
					password: {
						required: "Please provide a password",
						minlength: "Your password must be at least 5 characters long"
					},
					confirm_password: {
						required: "Please provide a password",
						minlength: "Your password must be at least 5 characters long",
						equalTo: "Please enter the same password as above"
					},
					email: "Please enter a valid email address",
					agree: "Please accept our policy"
				},
				errorElement: "em",
				errorPlacement: function ( error, element ) {
					error.addClass( "invalid-feedback" );
					if ( element.prop( "type" ) === "checkbox" ) {
						error.insertAfter( element.next( "label" ) );
					} else {
						error.insertAfter( element );
					}
				},
				highlight: function ( element, errorClass, validClass ) {
					$( element ).addClass( "is-invalid" ).removeClass( "is-valid" );
				},
				unhighlight: function (element, errorClass, validClass) {
					$( element ).addClass( "is-valid" ).removeClass( "is-invalid" );
				}
			} );
		} );
```

如果表单校验成功就调用ajax发送到后端进行后端校验，即密码和用户是否匹配，表单发送到后端的密码是包括经过md5加密的密码，后端对输入密码进行md5加密，比较两者是否相同。

如果成功，前端跳转到list界面，登录成功

除了在前端通过jQuery校验和后端的编码校验，还可以用jsr303的校验工具，如注解校验等后端校验，@valid和各种校验注解配合使用

## 自定义校验注解

```java
public class LoginVo {
    @NotNull
	@IsMobile     //自定义校验注解
	private String mobile;
    @NotNull
	@Length(min=32)
	private String password;
}
```

```java
//标注在字段上，方法上
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { IsMobileValidator.class })//校验包里的注解
public @interface IsMobile {
	boolean required() default true;
	String message() default "手机号码格式有误!";
	Class<?>[] groups() default { };  
	Class<? extends Payload>[] payload() default { }; //校验包里的方法
}
```

和普通的注解还有点不同的，还要提供注解校验器

```java
//实现校验器的接口，注解IsMobile  校验类型String
public class IsMobileValidator implements ConstraintValidator<IsMobile,String>{
	private boolean required=false;
	public void initialize(IsMobile constraintAnnotation) {
		constraintAnnotation.required();//先初始化方法
	}
	public boolean isValid(String value, ConstraintValidatorContext context) {
		if(required) {          //查看值是否是必须的
			return ValidatorUtil.isMobile(value);
		}else {
			if(StringUtils.isEmpty(value)) {  //required
				return true;
			}else {
				return ValidatorUtil.isMobile(value);
			}
		}
	}
}
```



## 全局异常处理

即使校验失败，由于注解没有显式地抛出异常，没有异常处理器，所以显示不是很明显，所以，自定义一些全局异常处理方法

定义全局异常类，继承runtimeException，异常中带着状态码和状态描述

定义全局异常的处理器，ControllerAdvice，定义处理异常范围，返回一些特定响应信息，这个响应信息在一个应用中通常也是需要统一设计。

```java
@ControllerAdvice
@ResponseBody
public class GlobalExceptionHandler {
	//拦截什么异常
	@ExceptionHandler(value=Exception.class)//拦截所有的异常
	public Result<String> exceptionHandler(HttpServletRequest request, Exception e){
		e.printStackTrace();
		if(e instanceof GlobalException) {
			GlobalException ex=(GlobalException) e;
			CodeMsg cm=ex.getCm();
			return Result.error(cm);
		}
		if(e instanceof BindException) {//是绑定异常的情况
			//强转
			BindException ex=(BindException) e;
			//获取错误信息
			List<ObjectError> errors=ex.getAllErrors();
			ObjectError error=errors.get(0);
			String msg=error.getDefaultMessage();
			return Result.error(CodeMsg.BIND_ERROR.fillArgs(msg));
		}else {//不是绑定异常的情况
			return Result.error(CodeMsg.SERVER_ERROR);
		}
	}
}
```

## 分布式session

分布式服务器中的session如何处理？

用户的多个请求到达不同的服务器中，session就没法用，可以用服务器session同步的方法，但是性能有限

这里采用方法：

利用一台缓存服务器集中管理session，即利用缓存统一管理session。

登录成功之后生成token，把token和当前用户作为键值对保存到Redis缓存中，然后写入到 coockie，返回给客户端，也就是写入到response中。所以 addCookie(token，response)方法。返回response中setCookie带上了cookie的值，客户端之后再发送request的时候，会把cookie带上 

```java
//生成cookieString 
token = UUIDUtil.uuid();   
//实际的UUID生成的是32位长的字符串，这里把中间的横线去掉了   2c801462-03a1-4f1b-b28b-ac34afed3454
addCookie(user,token,response);
```

```java
	public void addCookie(MiaoshaUser user,String token,HttpServletResponse response) {
		redisService.set(MiaoshaUserKey.token, token, user);
		Cookie cookie = new Cookie(COOKIE1_NAME_TOKEN, token);
		// 设置cookie的有效期，与session有效期一致
		cookie.setMaxAge(MiaoshaUserKey.token.expireSeconds());
		// 设置网站的根目录
		cookie.setPath("/");
		// 需要写到response中
		response.addCookie(cookie);
	}
```

**session更新过期时间：**

session的过期时间应该随着最后一次访问的时间不断更新，这里就是采用每次从缓存中查询的时候，都重新保存一次，同时cookie对象也重新生成一次，这样两者的过期时间都会更新

## 自定义参数解析器

在不同的请求中，可能都要去缓存中查一次当前用户是否已经存在，如果不存在就让其登录，如果已经存在了，就直接从缓存中拿到用户对象，执行请求。在不同的请求中多次重复查询session，会很繁琐，可以把这些工作作为一个重用的功能。采用的方法是，在方法参数中直接把user对象作为参数，这样就不用在方法中来做这些操作。而把这些操作转移到参数解析器中，ArgumentResolver，框架是调用这些参数解析器给方法参数赋值的。

```java
@Configuration
public class WebConfig extends WebMvcConfigurerAdapter{
	@Autowired
	UserArgumentResolver userArgumentResolver;
	/**
	 * 设置一个MiaoshaUser参数给，toList使用
	 */
	@Override
	public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {
		//将UserArgumentResolver注册到config里面去	
		argumentResolvers.add(userArgumentResolver);
	}
}
```

```java
//将UserArgumentResolver注册到config里面去
@Service
public class UserArgumentResolver implements HandlerMethodArgumentResolver{
	//既然能注入service，那么可以用来容器来管理，将其放在容器中
	@Autowired					
	MiaoshaUserService miaoshaUserService;
	
	public Object resolveArgument(MethodParameter arg0, ModelAndViewContainer arg1, NativeWebRequest webRequest,
			WebDataBinderFactory arg3) throws Exception {
		HttpServletRequest request=webRequest.getNativeRequest(HttpServletRequest.class);
		HttpServletResponse response=webRequest.getNativeResponse(HttpServletResponse.class);
		//获取请求参数中的Token
		String paramToken=request.getParameter(MiaoshaUserService.COOKIE1_NAME_TOKEN);
		System.out.println("@UserArgumentResolver-resolveArgument  paramToken:"+paramToken);
		//获取cookie中的Token
		String cookieToken=getCookieValue(request,MiaoshaUserService.COOKIE1_NAME_TOKEN);
		System.out.println("@UserArgumentResolver-resolveArgument  cookieToken:"+cookieToken);
		if(StringUtils.isEmpty(cookieToken)&&StringUtils.isEmpty(paramToken))
		{
			return null;
		}
		String token= StringUtils.isEmpty(paramToken)?cookieToken:paramToken;
		//从缓存中获得对象
		MiaoshaUser user=miaoshaUserService.getByToken(token,response);
		//取得已经保存的user，因为在用户登录的时候,user已经保存到threadLocal里面了，因为拦截器首先执行，然后才是取得参数
		//MiaoshaUser user=UserContext.getUser();
		return user;
	}
	//判断参数类型是否支持参数解析
	public boolean supportsParameter(MethodParameter parameter) {
		//返回参数的类型
		Class<?> clazz=parameter.getParameterType();
		return clazz==MiaoshaUser.class;    //只对特定类型做参数解析
	}
}
```

# 商品列表页



## 数据库表设计

四个表设计

商品表、秒杀商品表、订单表、秒杀订单表、用户表

秒杀商品表和商品表分开。原因：每次秒杀活动都会操作数据库，修改秒杀商品的字段，因为每次秒杀时候。对应的秒杀时间段，秒杀实现，秒杀功能，价格等都不同，商品表不易于维护。而且，秒杀商品的个数和普通商品的个数是独立计算的，不同于普通商品的库存字段。

秒杀订单表，单独拿出一个秒杀订单表，设计唯一索引可以避免发生用户重复秒杀

```java
	create table goods
	(
	id BIGINT(20) primary key not null auto_increment,
	goods_name varchar(16) DEFAULT NULL,
	goods_title varchar(64) DEFAULT NULL,
	goods_img varchar(64) DEFAULT NULL,
	goods_detail LONGTEXT,
	goods_price DECIMAL(10,2) DEFAULT '0.00',
	goods_stock INT(11) DEFAULT '0' 
	);
	create table miaosha_goods
	(
	id BIGINT(20) primary key not null auto_increment,
	goods_id BIGINT(20)  DEFAULT NULL,
	miaosha_price DECIMAL(10,2) DEFAULT '0.00',
	stock_count INT(11) DEFAULT NULL,
	start_date datetime DEFAULT NULL,
	end_date datetime DEFAULT NULL
	);

	create table miaosha_order
	(
	id BIGINT(20) primary key not null auto_increment,
	user_id BIGINT(20)  DEFAULT NULL,
	order_id BIGINT(20)  DEFAULT NULL,
	goods_id BIGINT(20)  DEFAULT NULL	
	);

	create table order_info
	(
	id BIGINT(20) primary key not null auto_increment,
	user_id BIGINT(20)  DEFAULT NULL,
	goods_id BIGINT(20)  DEFAULT NULL,
	/*收获地址*/
	delivery_addr_id BIGINT(20)  DEFAULT NULL,
	goods_name varchar(16) DEFAULT NULL,
	goods_count INT(11)  DEFAULT '0',
	goods_price decimal(10,2) DEFAULT '0.00',
	order_channel TINYINT(4) DEFAULT '0',
	order_status TINYINT(4) DEFAULT '0',
	create_date datetime DEFAULT NULL,
	pay_date datetime DEFAULT NULL	
	);
	
	create table miaosha_user
	(
	id BIGINT(20) primary key not null auto_increment,
	nickname VARCHAR(255) NOT NULL,
	pwd VARCHAR(32) DEFAULT NULL,
	salt VARCHAR(10) DEFAULT NULL,
	head VARCHAR(128) DEFAULT NULL,
	register_date DATETIME DEFAULT NULL,
	last_login_time DATETIME DEFAULT NULL,
	login_count INT(11) DEFAULT 0
	);

```

## 商品列表显示

这里为了把商品信息和秒杀信息都展示出来，需要把商品表和秒杀商品表链接起来查询，同时返回的对象是包含了两个表信息的对象。这里重新定义了一个GoodsVo，继承了Goods对象，并新增了秒杀商品信息。

连接查询

```java
@Select("select g.*,mg.stock_count,mg.start_date,mg.end_date,mg.miaosha_price from miaosha_goods mg left join goods g on mg.goods_id=g.id where g.id=#{goodsId}")  
	public GoodsVo getGoodsVoByGoodsId(@Param("goodsId")long goodsId);
```



## 秒杀倒计时

前端通过定时回调函数的方式，实现倒计时的功能  setTimeout()函数

为了显示秒杀倒计时，秒杀开始，秒杀结束等状态，设计状态变量来做判断

```js
$(function(){
		countDown();
	});
	function countDown(){
		//获取秒杀倒计时进行判断，0-->正在进行秒杀,-1-->秒杀结束,remailSeconds>0-->代表倒计时
		var remailSeconds=$("#remailSeconds").val();
		var timeout;
		if(remailSeconds>0){//秒杀还没有开始，进行倒计时功能
			$("#buyButton").attr("disabled",true);
			//倒计时
			timeout=setTimeout(function(){
				$("#countDown").text(remailSeconds-1);//改变显示的数字
				$("#remailSeconds").val(remailSeconds-1);//remailSeconds这是input
				countDown();
			},1000);//一秒钟之后回调函数
		}else if(remailSeconds==0){//正在进行秒杀
			$("#buyButton").attr("disabled",false);
			if(timeout){//如果timeout有值的情况
				clearTimeout(timeout);
			}
			//将文案修改
			$("#miaoshaTip").html("秒杀进行中");
		}else{
			//小于0的情况，秒杀结束，将秒杀按钮设置为不可点击
			$("#buyButton").attr("disabled",true);
			$("#miaoshaTip").html("秒杀结束");
		}
	}
```

remailSeconds的计算是从第一次进入商品详情页的请求到达后端后，在后端计算得出的。

```java
    @RequestMapping(value="/to_detail_html/{goodsId}")  
	@ResponseBody
	public String toDetailCachehtml(Model model,MiaoshaUser user,
			HttpServletRequest request,HttpServletResponse response,@PathVariable("goodsId")long goodsId) {//id一般用snowflake算法
		// 1.取缓存
		// public <T> T get(KeyPrefix prefix,String key,Class<T> data)
		String html = redisService.get(GoodsKey.getGoodsDetail, ""+goodsId, String.class);//不同商品页面不同的详情
		if (!StringUtils.isEmpty(html)) {
			return html;
		}
		//缓存中没有，则将业务数据取出，放到缓存中去。
		model.addAttribute("user", user);
		GoodsVo goods=goodsService.getGoodsVoByGoodsId(goodsId);
		model.addAttribute("goods", goods);
		//既然是秒杀，还要传入秒杀开始时间，结束时间等信息
		long start=goods.getStartDate().getTime();
		long end=goods.getEndDate().getTime();
		long now=System.currentTimeMillis();
		//秒杀状态量
		int status=0;
		//开始时间倒计时
		int remailSeconds=0;
		//查看当前秒杀状态
		if(now<start) {//秒杀还未开始，--->倒计时
			status=0;
			remailSeconds=(int) ((start-now)/1000);  //毫秒转为秒
		}else if(now>end){ //秒杀已经结束
			status=2;
			remailSeconds=-1;  //毫秒转为秒
		}else {//秒杀正在进行
			status=1;
			remailSeconds=0;  //毫秒转为秒
		}
		model.addAttribute("status", status);
		model.addAttribute("remailSeconds", remailSeconds);
		// 2.手动渲染 使用模板引擎 templateName:模板名称 String templateName="goods_detail";
		SpringWebContext context = new SpringWebContext(request, response, request.getServletContext(),
				request.getLocale(), model.asMap(), applicationContext);
		html = thymeleafViewResolver.getTemplateEngine().process("goods_detail", context);
		// 将渲染好的html保存至缓存
		if (!StringUtils.isEmpty(html)) {
			redisService.set(GoodsKey.getGoodsDetail, ""+goodsId, html);
		}
		return html;//html是已经渲染好的html文件
	}
```

# 秒杀功能

秒杀按钮按下之后调用执行秒杀功能的控制器

主要包括

判断当前商品库存大小

查询订单信息，是否成功

调用秒杀服务执行事务性的操作

关键是各个控制器，服务层，dao层之间的调用关系

```java
	@RequestMapping("/do_miaosha")
	public String toList(Model model,MiaoshaUser user,@RequestParam("goodsId") Long goodsId) {
		model.addAttribute("user", user);//传入user对象
		//如果用户为空，则返回至登录页面
		if(user==null){
			return "login";
		}
		GoodsVo goodsvo=goodsService.getGoodsVoByGoodsId(goodsId);
		//判断商品库存，库存大于0，才进行操作，多线程下会出错
		int  stockcount=goodsvo.getStockCount();		
		if(stockcount<=0) {//失败			库存至临界值1的时候，此时刚好来了加入10个线程，那么库存就会-10
			model.addAttribute("errorMessage", CodeMsg.MIAOSHA_OVER_ERROR);
			return "miaosha_fail";
		}
		//判断这个秒杀订单形成没有，判断是否已经秒杀到了，避免一个账户秒杀多个商品 
		MiaoshaOrder order=orderService.getMiaoshaOrderByUserIdAndCoodsId(user.getId(),goodsId);
		if(order!=null) {//重复下单
			model.addAttribute("errorMessage", CodeMsg.REPEATE_MIAOSHA);
			return "miaosha_fail";
		}
		//可以秒杀，原子操作：1.库存减1，2.下订单，3.写入秒杀订单--->是一个事务
		OrderInfo orderinfo=miaoshaService.miaosha(user,goodsvo);
		//如果秒杀成功，直接跳转到订单详情页上去。
		model.addAttribute("orderinfo", orderinfo);
		model.addAttribute("goods", goodsvo);
		return "order_detail";//返回页面login
	}
```

# Jmeter压测和Redis的压测

 **QPS每秒查询率(Query Per Second)** 
每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。 

 性能瓶颈在哪？数据库查询压力

并发在多少时，QPS是多少？

Jmeter的使用，自定义变量

1、 redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000

100个并发，100000个请求

会详细显示每个操作的执行信息，包括百分比速率

2、 redis-benchmark -h 127.0.0.1 -p 6379  -q -d 100

存取大小为100字节的数据包

```shell
[binli@bin ~]$  redis-benchmark -h 127.0.0.1 -p 6379  -q -d 100
PING_INLINE: 76745.97 requests per second
PING_BULK: 78926.60 requests per second
SET: 81168.83 requests per second
GET: 77339.52 requests per second
INCR: 78369.91 requests per second
LPUSH: 82781.46 requests per second
RPUSH: 79936.05 requests per second
LPOP: 80128.20 requests per second
RPOP: 78926.60 requests per second
SADD: 81499.59 requests per second
HSET: 81499.59 requests per second
SPOP: 81168.83 requests per second
LPUSH (needed to benchmark LRANGE): 78247.26 requests per second
LRANGE_100 (first 100 elements): 82101.80 requests per second
LRANGE_300 (first 300 elements): 81699.35 requests per second
LRANGE_500 (first 450 elements): 83194.67 requests per second
LRANGE_600 (first 600 elements): 77700.08 requests per second
MSET (10 keys): 84674.01 requests per second
```

3、redis-benchmark  -t set,lpush -n 100000 -q

只测试某些操作的性能

```shell
SET: 81499.59 requests per second
LPUSH: 77459.34 requests per second
```

4、redis-benchmark  -n 100000 -q script load "redis.call('set','foo','bar')";

只测试某些数值存取的性能

```shell
script load redis.call('set','foo','bar'): 78125.00 requests per second
```

SpringBoot打war包

添加Tomcat的provided依赖

修改打包类型为war

主类继承springbootservletinitializer

把war包放到webapp目录下，记得路径上要加上项目名

Java -jar ***.jar

会自动去meta_info中去找maniFest mf文件，里面记录了函数入口的信息，Main class 和start class

Jmeter压测出现的问题

**Windows 提供给 TCP/IP链接的端口为 1024-5000，并且要四分钟来循环回收他们。就导致我们在短时间内跑大量的请求时将端口占满了。**

所以在第一次测试过后，如果马上进行接下来的测试就可能会造成连接阻塞，系统卡着，测试大量报错。

# 页面优化

页面缓存+URL缓存+对象缓存

页面静态化，前后端分离

目标：减少流量和减少连接数

缓存技术：

浏览器静态页面缓存——》CDN缓存——》Nginx缓存——》应用程序页面缓存/对象缓存——》数据库

## 页面缓存

1、取缓存，如果有直接返回，如果没有

一般页面由springboot渲染然后返回，这里直接设置返回的是text/HTML，然后结合缓存来进行存储。

2、手动渲染模板，并且保存在缓存中

ThymeleafViewResolver 自动在容器中，手动渲染就是利用这个对象

3、结果输出

URL缓存是根据查询条件不同的，带有参数的页面，对不同页面缓存。

**一般，页面缓存和URL缓存时间比较短，适合场景：变化不大的页面。如果分页，不会全部缓存，一般缓存前一两页。**

```java
    @RequestMapping(value="/to_list1",produces="text/html") 
	@ResponseBody
	public String toListCache(Model model,MiaoshaUser user,HttpServletRequest request,
			HttpServletResponse response) {
		// 1.取缓存
		String html = redisService.get(GoodsKey.getGoodsList, "", String.class);
		if (!StringUtils.isEmpty(html)) {
			return html;
		}
		model.addAttribute("user", user);
		//查询商品列表
		List<GoodsVo> goodsList= goodsService.getGoodsVoList();
		model.addAttribute("goodsList", goodsList);
	    //2.手动渲染  使用模板引擎  templateName:模板名称 context对象
		SpringWebContext context=new SpringWebContext(request,response,request.getServletContext(),
				request.getLocale(),model.asMap(),applicationContext);
		html=thymeleafViewResolver.getTemplateEngine().process("goods_list", context);
		//保存至缓存
        //key---GoodsKey:gl---缓存goodslist这个页面
		if(!StringUtils.isEmpty(html)) {
		redisService.set(GoodsKey.getGoodsList, "", html);  
		}
		return html;
	}
```

## 页面静态化

未作页面静态化：请求某一个页面，访问缓存，查看缓存中是否有，缓存中有直接返回，缓存中没有的话，将数据渲染到html页面再存到缓存，再将整个html页面返回给客户端显示。

做了页面静态化：第一次是去请求后台要渲染好的html页面，之后的请求都是直接访问用户本地浏览器的缓存的html页面 ，静态资源，然后前端通过Ajax来访问后端，只去获取页面需要显示的数据返回即可。

都是纯的html，通过js或者ajax来请求服务器，如果做了静态化，浏览器可以把html缓存在客户端。

需要在配置文件中配置静态资源相关

```properties
spring.resources.add-mappings=true
spring.resources.cache-period=3600 
spring.resources.chain.cache=true
spring.resources.chain.enabled=true
spring.resources.chain.gzipped=true 
spring.resources.chain.html-application-cache=true
spring.resources.static-locations=classpath:/static/
```

前端页面跳转到静态页面上去

```java
<td><a th:href="'/goods_detail.htm?goodsId='+${goods.id}">详情</a></td>
```

然后执行页面初始化

```java
	function getDetail(){
		//getQueryString获取请求路径中的参数
		var goodsId=getQueryString("goodsId");
		//alert(goodsId);
		$.ajax({
			url:"/goods/detail/"+goodsId,
			type:"GET",
			success:function(data){
				if(data.code==0){		
					//使用render方法渲染页面							
					render(data.data);
				}else{
					layer.msg(data.msg);
				}
			},
			error:function(){
				layer.msg("请求有误！");
			}
		});		
	}
```

```js
function render(detail) {
	//alert(detail.status);
	var miaoshaStatus = detail.status;
	var remailSeconds = detail.remailSeconds;
	var goods = detail.goodsVo;
	var user = detail.user;
	if (user != null) {
		//展示相应的
		$("#userTip").hide();
	}
	$("#goodsName").text(goods.goodsName);
	$("#goodsImg").attr("src", goods.goodsImg); //.text();
	$("#startTime").text(goods.startDate); //还没有格式化
	$("#remailSeconds").val(remailSeconds);
	$("#goodsId").val(goods.id);
	$("#goodsPrice").text(goods.goodsPrice); //goodsStock----- stockCount
	$("#miaoshaPrice").text(goods.miaoshaPrice);
	$("#stockCount").text(goods.goodsStock);
	countDown();
}
```
 秒杀中的静态化：

goods_detail.htm通过ajax请求获得商品详情信息，并实现倒计时等功能。秒杀按钮实现点击事件，执行do_miao()方法。

调用后台秒杀方法，调用轮询方法获得结果，如果成功则将订单号传到order_detail.htm中，通过ajax请求得到订单信息，渲染页面。





## 对象缓存

对象在更改时，除了修改数据库，还要更新缓存信息

所以在调用不同模块之间方法时，要调用上层的service方法

```java
public MiaoshaUser getById(long id) {
		//1.取缓存	---先根据id来取得缓存
		MiaoshaUser user=redisService.get(MiaoshaUserKey.getById, ""+id, MiaoshaUser.class);
		//能再缓存中拿到
		if(user!=null) {
			return user;
		}
		//2.缓存中拿不到，那么就去取数据库
		user=miaoshaUserDao.getById(id);
		//3.设置缓存
		if(user!=null) {
			redisService.set(MiaoshaUserKey.getById, ""+id, user);
		}
		return user;
	}
```

对象缓存的注意问题：

如何保证数据库和缓存数据的一致性？

MiaoshaUserService里面增加getById方法，**先去取缓存，如果缓存中拿不到，那么就去取数据库，然后再设置到缓存中去**。

**更新用户密码：更新数据库与缓存，一定保证数据一致性，修改token关联的对象以及id关联的对象，先更新数据库后删除缓存，不能直接删除token，删除之后就不能登录了，再将token以及对应的用户信息一起再写回缓存里面去。**

```java
	public boolean updatePassword(String token,long id,String passNew) {
		//1.取user对象，查看是否存在
		MiaoshaUser user=getById(id);
		if(user==null) {
			throw new GlobalException(CodeMsg.MOBILE_NOTEXIST);
		}
		//2.更新密码
		MiaoshaUser toupdateuser=new MiaoshaUser();
		toupdateuser.setId(id);
		toupdateuser.setPwd(MD5Util.inputPassToDbPass(passNew, user.getSalt()));
		miaoshaUserDao.update(toupdateuser);
		//3.更新数据库与缓存，一定保证数据一致性，修改token关联的对象以及id关联的对象
		redisService.delete(MiaoshaUserKey.getById, ""+id);
		//不能直接删除token，删除之后就不能登录了
		user.setPwd(toupdateuser.getPwd());
		redisService.set(MiaoshaUserKey.token, token,user);
		return true;
	}
```



# 压测

## 解决超卖等问题

**避免超卖现象：**

在数据库更新数据时做个判断，只有当库存量大于0时才可以更新，由于数据库更新表时会加锁，所以能够避免出现负数的库存的问题

**解决一个用户买到两个秒杀商品：**

在用户秒杀到商品后生成秒杀订单，限制每个用户只能秒杀一个商品的话，就将订单生成唯一索引，和用户ID相关的，这样插入订单时就只能插入一个。

**数据库连接，并发线程太多时会导致连接出错，不知道为什么？**

可能是操作系统对TCP连接端口的限制，

cache aside pattern

get 和 post区别的核心，在于幂等性

CDN 把数据缓存到分布式网络节点上

静态资源压缩



缓存导致数据不一致



# 接口优化

开源的分库分表的中间件 Mycat

秒杀业务场景，并发量很大，瓶颈在数据库，怎么解决，加缓存。用户发起请求时，从浏览器开始,在浏览器上做页面静态化直接将页面缓存到用户的浏览器端，然后请求到达网站之前可以部署CDN节点，让请求先访问CDN，到达网站时候使用页面缓存。页面缓存再进一步的话，粒度再细一点的话就是对象缓存。缓存层依次请求完之后，才是数据库。通过一层一层的访问缓存逐步的削减到达数据库的请求数量，这样才能保证网站在大并发之下抗住压力。


基于rabbitmq的消息队列，实现异步下单功能

**优化思路：**

1、系统初始化时，将商品数量添加到缓存中

2、受到请求后，Redis减一后判断是否正确，不足则直接返回

3、消息入队，立刻返回

4、消息出队，生成订单，减少库存

5、客户端轮询，看订单是否完成

## 系统初始化

如何在系统加载时做一些事情？

可以让service控制器实现initializingBean接口

```java
public class MiaoshaController implements InitializingBean
```

实现afterPropertiesSet()方法

```java
	/**
	 * 系统初始化的时候做的事情。
	 * 在容器启动时候，检测到了实现了接口InitializingBean之后，
	 */
	public void afterPropertiesSet() throws Exception {
		List<GoodsVo> goodslist=goodsService.getGoodsVoList();//查询库存
		if(goodslist==null) {
			return;
		}
          //如果不是null的时候，将库存加载到redis里面去
            //prefix---GoodsKey:gs ,	 key---商品id,	 value
		for(GoodsVo goods:goodslist) {
      redisService.set(GoodsKey.getMiaoshaGoodsStock, 
                        ""+goods.getId(), goods.getStockCount());
		}
	}
```

## 异步订单

  做缓存+消息队列
	 1.系统初始化，把商品库存数量加载到Redis上面来。
	 2.收到请求，Redis预减库存。
	 3.请求入队，立即返回排队中。
	 4.请求出队，生成订单，减少库存（事务）。
	 5.客户端轮询，是否秒杀成功。

### 添加消息队列

1.如果用户为空，则返回至登录页面

2.预减少库存，减少redis里面的库存，为了减少对数据库访问

3.判断减少数量1之后的stock，区别于查数据库时候的stock<=0

4.判断这个秒杀订单形成没有，判断是否已经秒杀到了，避免一个账户秒杀多个商品

5.正常请求，入队，发送一个秒杀message到队列里面去，入队之后客户端应该进行轮询。

```java
@RequestMapping(value="/{path}/do_miaosha_ajaxcache",method=RequestMethod.POST)
	@ResponseBody
	public Result<Integer> doMiaoshaCache(Model model,MiaoshaUser user,
			@RequestParam(value="goodsId",defaultValue="0") long goodsId,
			@PathVariable("path")String path) {
		model.addAttribute("user", user);
		//1.如果用户为空，则返回至登录页面
		if(user==null){
			return Result.error(CodeMsg.SESSION_ERROR);
		}
		//验证path,去redis里面取出来然后验证。
		boolean check=miaoshaService.checkPath(user,goodsId,path);
		if(!check) {
			return Result.error(CodeMsg.REQUEST_ILLEAGAL);
		}
		//2.预减少库存，减少redis里面的库存
		long stock=redisService.decr(GoodsKey.getMiaoshaGoodsStock,""+goodsId);
		//3.判断减少数量1之后的stock，区别于查数据库时候的stock<=0
        //线程不安全---失败 库存至临界值1的时候，此时刚好来了加入10个线程，那么库存就会-10
		if(stock<0) {
			return Result.error(CodeMsg.MIAOSHA_OVER_ERROR);
		}
		//4.判断这个秒杀订单形成没有，判断是否已经秒杀到了，避免一个账户秒杀多个商品
		MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdAndGoodsId(user.getId(), goodsId);
		if (order != null) {// 重复下单
		   // model.addAttribute("errorMessage", CodeMsg.REPEATE_MIAOSHA);
			return Result.error(CodeMsg.REPEATE_MIAOSHA);
		}
		//5.正常请求，入队，发送一个秒杀message到队列里面去，入队之后客户端应该进行轮询。
		MiaoshaMessage mms=new MiaoshaMessage();
		mms.setUser(user);
		mms.setGoodsId(goodsId);
		mQSender.sendMiaoshaMessage(mms);
		//返回0代表排队中
		return Result.success(0);
	}
```

### 监听器实现

监听消息队列，拿到请求message，执行秒杀的判断和操作

```java
	@RabbitListener(queues=MQConfig.MIAOSHA_QUEUE)//指明监听的是哪一个queue
	public void receiveMiaosha(String message) {
		log.info("receiveMiaosha message:"+message);
		//通过string类型的message还原成bean
		//拿到了秒杀信息之后。开始业务逻辑秒杀
		MiaoshaMessage mm=RedisService.stringToBean(message, MiaoshaMessage.class);
		MiaoshaUser user=mm.getUser();
		long goodsId=mm.getGoodsId();
		GoodsVo goodsvo=goodsService.getGoodsVoByGoodsId(goodsId);
        //获得库存
		int  stockcount=goodsvo.getStockCount();		
		//1.判断库存不足
		if(stockcount<=0) {
            //失败  库存至临界值1的时候，此时刚好来了加入10个线程，那么库存就会-10
			return;
		}
		//2.判断这个秒杀订单形成没有，判断是否已经秒杀到了，避免一个账户秒杀多个商品
		MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdAndCoodsId(user.getId(), goodsId);
		if (order != null) {// 重复下单
			return;
		}
		//原子操作：1.库存减1，2.下订单，3.写入秒杀订单--->是一个事务
		miaoshaService.miaosha(user,goodsvo);
	}
```

### 执行秒杀操作

```java
	@Transactional
	public OrderInfo miaosha1(MiaoshaUser user, GoodsVo goodsvo) {
		//1.减少库存,即更新库存
        //考虑减少库存失败的时候，不进行写入订单
		boolean success=goodsService.reduceStock1(goodsvo);
		if(success) {
			//2.下订单,其中有两个订单: order_info  miaosha_order
			OrderInfo orderinfo=orderService.createOrder_Cache(user, goodsvo);
			return orderinfo;	
		}else {//减少库存失败
			//做一个标记，代表商品已经秒杀完了,为了给前端轮询结果
			setGoodsOver(goodsvo.getId());
			return null;
		}
	}
```

## 客户端轮询

### 后端实现

```java
   @RequestMapping(value = "/result", method = RequestMethod.GET)
	@ResponseBody
	public Result<Long> doMiaoshaResult(Model model, MiaoshaUser user,
			@RequestParam(value = "goodsId", defaultValue = "0") long goodsId) {
		long result=miaoshaService.getMiaoshaResult(user.getId(),goodsId);
		System.out.println("轮询 result："+result);
		return Result.success(result);
	}
```

```java
	public long getMiaoshaResult(Long userId, long goodsId) {
		MiaoshaOrder order=orderService.getMiaoshaOrderByUserIdAndCoodsId_Cache(userId, goodsId);
		//秒杀成功
		if(order!=null) {
			System.out.println("!!@orderId:"+order.getId());
			return order.getOrderId();
		}
		else {
			//查看商品是否卖完了,这里在缓存中加了一个标记，
            //如果某个订单完成后，数量为0就标记true
			boolean isOver=getGoodsOver(goodsId);  
			if(isOver) {//商品卖完了
				return -1;
			}else {		//商品没有卖完
				return 0;
			}
		}
	}
```

### 前端实现

```java
//做轮询
	function getMiaoshaResult(goodsId) {
		$.ajax({
			url : "/miaosha/result",
			type : "GET",
			data : {
				goodsId : $("#goodsId").val()
			},
			success : function(data) {
				if (data.code == 0) {
					var result = data.data;
					if (result < 0) {
						layer.msg("抱歉，秒杀失败!");
					} else if (result == 0) {
					  //继续轮询,这里是在等待队列时不断循环查询
                       setTimeout(function() {
							getMiaoshaResult(goodsId);
						}, 50);//50ms之后继续轮询
						layer.msg(data.msg);
					} else {
						layer.confirm("恭喜你，秒杀成功!查看订单?", {
							btn : [ "确定", "取消" ]
						}, function() {
							//秒杀成功，跳转详情页面
							window.location.href = "order_detail.htm?orderId="
									+ result;
						}, function() {
							layer.closeAll();
						});//两个button对应两个函数
					}
					//轮询
					//getMiaoshaResult($("#goodsId").val());
				} else {
					layer.msg(data.msg);
				}
			},
			error : function() {
				layer.msg("请求有误！");
			}
		//token如果cookie里面有，会自己带过去
		});
	}
```



# Nginx横向拓展

nginx.cnf

LVS 

可以反向代理，横向拓展，设置缓存

# 接口隐藏

是为了避免恶意刷流量

秒杀开始前申请获得秒杀路径参数

前端先发送请求，获得路径参数，路径参数后端保存在缓存中，每个用户对应一个

后端秒杀收到请求先校验这个路径参数

```java
   <td>
	<div class="row">
		<div class="form-inline">
			<img id="vertifyCodeImg" width="80" height="30" style="display:none" onclick="refreshVCode()"></img>
				<input id="vertifyCode" class="form-control" style="display:none"></input>
				<button class="btn btn-primary" type="button" id="buyButton" onclick="getMiaoshaPath()">立即秒杀</button>  <!--设置点击事件获得秒杀地址-->
			</div>
		</div>
	</td> 	
     //获取秒杀地址
	function getMiaoshaPath() {
		var goodsId = $("#goodsId").val();
		$.ajax({
			url : "/miaosha/getPath",
			type : "GET",
			data : {
				goodsId : goodsId,
				vertifyCode:$("#vertifyCode").val()
			},
			success : function(data) {
				if (data.code == 0) {
					//获取秒杀地址
					var path = data.data;
					//拿到path之后，才去执行秒杀操作
					doMiaosha(path);
				} else {
					layer.msg(data.msg);
				}
			},
			error : function() {
				layer.msg("请求有误！");
			}
		//token如果cookie里面有，会自己带过去
		});
	}
```

前端函数，执行秒杀操作

```java
function doMiaosha(path) {
		$.ajax({
			url : "/miaosha/" + path + "/do_miaosha_ajaxcache",
			type : "POST",
			data : {
				goodsId : $("#goodsId").val()
			},
			success : function(data) {
				if (data.code == 0) {
					//轮询
					getMiaoshaResult($("#goodsId").val());
				} else {
					layer.msg(data.msg);
				}
			},
			error : function() {
				layer.msg("请求有误！");
			}
		//token如果cookie里面有，会自己带过去
		});
	}
```

后端校验路径

```java
@RequestMapping(value="/{path}/do_miaosha_ajaxcache",method=RequestMethod.POST)
	@ResponseBody
	public Result<Integer> doMiaoshaCache(Model model,MiaoshaUser user,
			@RequestParam(value="goodsId",defaultValue="0") long goodsId,
			@PathVariable("path")String path) {
		model.addAttribute("user", user);
		//1.如果用户为空，则返回至登录页面
		if(user==null){
			return Result.error(CodeMsg.SESSION_ERROR);
		}
		//验证path,去redis里面取出来然后验证。
		boolean check=miaoshaService.checkPath(user,goodsId,path);
		if(!check) {
			return Result.error(CodeMsg.REQUEST_ILLEAGAL);
		}
		//内存标记，减少对redis的访问 localMap.put(goodsId,false);
		boolean over=localMap.get(goodsId);
		//在容量满的时候，那么就打标记为true
		if(over) {
			return Result.error(CodeMsg.MIAOSHA_OVER_ERROR);
		}
		//2.预减少库存，减少redis里面的库存
		long stock=redisService.decr(GoodsKey.getMiaoshaGoodsStock,""+goodsId);
		//3.判断减少数量1之后的stock，区别于查数据库时候的stock<=0
		if(stock<0) {//线程不安全---失败	库存至临界值1的时候，此时刚好来了加入10个线程，那么库存就会-10
			return Result.error(CodeMsg.MIAOSHA_OVER_ERROR);
		}
		//4.判断这个秒杀订单形成没有，判断是否已经秒杀到了，避免一个账户秒杀多个商品
		MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdAndCoodsId(user.getId(), goodsId);
		if (order != null) {  // 重复下单
			// model.addAttribute("errorMessage", CodeMsg.REPEATE_MIAOSHA);
			return Result.error(CodeMsg.REPEATE_MIAOSHA);
		}
		//5.正常请求，入队，发送一个秒杀message到队列里面去，入队之后客户端应该进行轮询。
		MiaoshaMessage mms=new MiaoshaMessage();
		mms.setUser(user);
		mms.setGoodsId(goodsId);
		mQSender.sendMiaoshaMessage(mms);
		//返回0代表排队中
		return Result.success(0);
	}
```

# 图片验证

高并发下场景，在刚刚开始秒杀的那一瞬间，迎来的并发量是最大的，减少同一时间点的并发量，将并发量分流也是一种减少数据库以及系统压力的措施（使得1s中来10万次请求过渡为10s中来10万次请求）

思路：点击秒杀之前，先输入验证码，分散用户的请求。具体实现是服务端生成类似1+2-3的验证码，把结果计算出来存至服务端（缓存），把验证码图片发至客户端，此后客户端在请求秒杀地址前输入验证码值发请求验证，（去缓存里面取得值验证是否与用户输入相同），验证通过才会动态生成秒杀地址给前端。

# 接口限流

用拦截器对请求做处理

设计一个接口流量判断，采用基于缓存的简单计数器，判断一段时间内的计数是否超过给定值，如果查过了就返回异常提示。为了避免每个请求中都做同样的判断，而且不同接口的请求限制可能不同，所以设计一个注解。然后用一个拦截器来对该注解进行处理，根据注解参数来执行统一判断。

**判断用户登录**
这里将之前原先定义在解析用户参数的代码封装。然后在将用这个封装的用户信息，set到ThreadLocal 中，本地线程副本，该变量与线程绑定，存取只会存取在本地线程中。然后之前获取用户的代码直接取到该用户即可。
**判断访问次数与失效时间（缓存时间）**
判断访问次数count ,从缓存中存取，然后根据注解时间，动态设置缓存的过期时间。

**出问题了之后，根据debug端点调试，和浏览器开发者模式，看请求的返回数据等**

```java
@Target(METHOD)  //注解
@Retention(RUNTIME)
public @interface AccessLimit {
	int seconds();
	int maxCount();
	boolean needLogin() default true;
}
```

```java
@Service //拦截器
public class AccessInterceptor extends HandlerInterceptorAdapter{
	@Autowired
	MiaoshaUserService miaoshaUserService;
	@Autowired
	RedisService redisService;
    //重写前置处理器
	@Override
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
		if(handler instanceof HandlerMethod) {
			//先去取得用户做判断
			MiaoshaUser user=getUser(request,response);
			//将user保存到ThreadLocal中，用于下一步的参数解析中绑定参数
			UserContext.setUser(user);
			HandlerMethod hm=(HandlerMethod)handler;
            //获得方法上的某个注解
			AccessLimit aclimit=hm.getMethodAnnotation(AccessLimit.class);
			//无该注解的时候，那么就不进行拦截操作
			if(aclimit==null) {
				return true;
			}
			//获取参数
			int seconds=aclimit.seconds();
			int maxCount=aclimit.maxCount();
			boolean needLogin=aclimit.needLogin();
			String key=request.getRequestURI();
			if(needLogin) {
				if(user==null) {
					//需要给客户端一个提示
					render(response, CodeMsg.SESSION_ERROR);
					return false;
				}
				//需要的登录
				key+="_"+user.getId();
			}else {//不需要登录
				//不需要操作
			}
			//限制访问次数
			//String key=uri+"_"+user.getId();
			//限定key5s之内只能访问5次，动态设置有效期
			AccessKey akey=AccessKey.expire(seconds);
			Integer count=redisService.get(akey, key, Integer.class);
			if(count==null) {
				redisService.set(akey, key, 1);
			}else if(count<maxCount) {
				redisService.incr(akey, key);
			}else {//超过5次
				render(response,CodeMsg.ACCESS_LIMIT);
				return false;
			}
		}
		return super.preHandle(request, response, handler);
	}
```



# 项目总结

## **项目的亮点：**

1. 使用分布式Seesion，可以实现让多台服务器同时可以响应。
2. 使用redis做缓存提高访问速度和并发量，减少数据库压力，利用内存标记减少redis的访问。
3. 使用页面静态化，加快用户访问速度，提高QPS，缓存页面至浏览器，前后端分离降低服务器压力。
4. 使用消息队列完成异步下单，提升用户体验，削峰和降流
5. 安全性优化：双重md5密码校验，秒杀接口地址的隐藏，接口限流防刷，数学公式验证码。

## **主要知识点：**

**分布式Seesion**

我们的秒杀服务，实际的应用可能不止部署在一个服务器上，而是分布式的多台服务器，这时候假如用户登录是在第一个服务器，第一个请求到了第一台服务器，但是第二个请求到了第二个服务器，那么用户的session信息就丢失了。
解决：session同步，无论访问那一台服务器，session都可以取得到，利用redis缓存的方法，另外使用一个redis服务器专门用于存放用户的session信息。这样就不会出现用户session丢失的情况。（每次需要session，从缓存中取即可）

 **redis缓解数据库压力**

本项目大量的利用了缓存技术，包括用户信息缓存（分布式session），商品信息的缓存，商品库存缓存，订单的缓存，页面缓存，对象缓存减少了对数据库服务器的访问

**通用缓存key封装**

大量的缓存引用也出现了一个问题，如何识别不同模块中的缓存（key值重复，如何辨别是不同模块的key）
解决：利用一个抽象类，定义BaseKey（前缀），在里面定义缓存key的前缀以及缓存的过期时间从而实现将缓存的key进行封装。让不同模块继承它，这样每次存入一个模块的缓存的时候，加上这个缓存特定的前缀，以及可以统一制定不同的过期时间。

**页面静态化（前后端分离）**

页面静态化的主要目的是为了加快页面的加载速度，将商品的详情和订单详情页面做成静态HTML（纯的HTML），数据的加载只需要通过ajax来请求服务器，并且做了静态化HTML页面可以缓存在客户端的浏览器。

**消息队列完成异步下单**

使用消息队列完成异步下单，提升用户体验，削峰和降流。

思路：
1. 系统初始化，把商品库存数量stock加载到Redis上面来。
2.后端收到秒杀请求，Redis预减库存，如果库存已经到达临界值的时候，就不需要继续请求下去，直接返回失败，即后面的大量请求无需给系统带来压力。
3.判断这个秒杀订单形成没有，判断是否已经秒杀到了，避免一个账户秒杀多个商品，判断是否重复秒杀。
4.库存充足，且无重复秒杀，将秒杀请求封装后消息入队，同时给前端返回一个code (0)，即代表返回排队中。（返回的并不是失败或者成功，此时还不能判断）
5.前端接收到数据后，显示排队中，并根据商品id轮询请求服务器（考虑200ms轮询一次）。
6.后端RabbitMQ监听秒杀MIAOSHA_QUEUE的这名字的通道，如果有消息过来，获取到传入的信息，执行真正的秒杀之前，要判断数据库的库存，判断是否重复秒杀，然后执行秒杀事务（秒杀事务是一个原子操作：库存减1，下订单，写入秒杀订单）。
7.此时，前端根据商品id轮询请求接口MiaoshaResult,查看是否生成了商品订单，如果请求返回-1代表秒杀失败，返回0代表排队中，返回>0代表商品id说明秒杀成功。

**安全性优化**

双重md5密码校验，秒杀接口地址的隐藏，接口限流防刷，数学公式验证码。

**优雅的代码编写**

接口的输出结果做了一个Result封装
对错误的代码做了一个CodeMsg的封装
访问缓存做了一个key的封装

## 项目难点及问题解决

## 1、**使用JMeter做压测的时候开启5000个线程，系统跑不起来，出现异常**

原因：修改配置文件中redis的配置项poolMaxTotal	将其设置成1000。

  ## 2、使用了大量缓存，那么就存在缓存击穿和缓存雪崩以及缓存一致性等问题？

**缓存穿透指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。** 
解决方案：对这些不存在的数据缓存一个空数据，对这类请求进行过滤。

**缓存雪崩指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。**
解决方案：
为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；
为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。
也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。
例如：首先针对不同的缓存设置不同的过期时间，比如session缓存，在userKey这个前缀中，设置是30分钟过期，并且每次用户响应的话更新缓存时间。这样每次取session,都会延长30分钟，相对来说，就减少了缓存过期的几率

**缓存一致性要求数据更新的同时缓存数据也能够实时更新。**
解决方案：
在数据更新的同时立即去更新缓存，**首先尝试从缓存读取，读到数据则直接返回；如果读不到，就读数据库，并将数据会写到缓存，并返回。**
在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新，**需要更新数据时，先更新数据库，然后把缓存里对应的数据失效掉（删掉）。**
保持缓存一致性：
**1. 对删除缓存进行重试，数据的一致性要求越高，我越是重试得快。**
**2. 定期全量更新，简单地说，就是我定期把后再全量加载。**
**3. 给所有的缓存一个失效期。**

**缓存 “无底洞” 现象**
指的是为了满足业务要求添加了大量缓存节点，但是性能不但没有好转反而下降了的现象。
产生原因：缓存系统通常采用 hash 函数将 key 映射到对应的缓存节点，随着缓存节点数目的增加，键值分布到更多的节点上，导致客户端一次批量操作会涉及多次网络操作，这意味着批量操作的耗时会随着节点数目的增加而不断增大。此外，网络连接数变多，对节点的性能也有一定影响。
**解决方案：**

1. 优化批量数据操作命令；
2. 减少网络通信次数；
3. 降低接入成本，使用长连接 / 连接池，NIO 等。



## 3.大量的使用缓存，对于缓存服务器，也有很大的压力，思考如何减少redis的访问？

在redis预减库存的时候，内存中维护一个isOvermap作为一个内存标记，当没有库存的时候，将其置为true。每次秒杀业务访问redis之前，查一下map标记，如果true说明没有库存，就直接返回失败，无需再去请求redis服务器。

## 4、在高并发请求的业务场景，大量请求来不及处理，甚至出现请求堆积时候？

消息队列，用来异步处理请求。每次请求过来，先不去处理请求，而是放入消息队列，然后在后台布置一个监听器，分别监听不同业务的消息队列，有消息来的时候，才进行秒杀业务逻辑。这样防止多个请求同时操作的时候，数据库连接过多的异常。

## 5、怎么保证一个用户不能重复下单？

解决：秒杀订单表中建立一个唯一索引（所引是用户Id与商品goodsId），使得第一个记录可以插入，第二个则出错，然后通过事务回滚，防止一个用户同时发出多个请求的处理，秒杀到多个商品。

唯一索引，即是唯一的意思，在数据库表结构中对字段添加唯一索引后进行数据库进行存储操作时数据库会判断库中是否已经存在此数据，不存在此数据时才能进行插入操作。

这虽然是个小技能，但实际上在业务开发中是个很实用的技能，比如在高并发业务中，数据库如何杜绝数据并发插入两条相同的订单号呢？添加一个唯一索引当然是最快捷的方法之一，当然是添加索引还是通过业务代码去解决因公司业务而定

## 6、怎么解决超卖现象？

超卖场景：不同用户在读请求的时候，发现商品库存足够，然后同时发起请求，进行秒杀操作，减库存，导致库存减为负数。

最简单的方法，更新数据库减库存的时候，进行库存限制条件，在reduceStock(GoodsVo goodsvo)这个方法里，sql要多加一个stock_count > 0 ，使用数据库特性来保证超卖的问题，只有stock_count还大于0的时候才去读stock_count然后减1操作

在Redis缓存中预先加载了商品库存量，在访问数据库前先对Redis库存量进行预减少，如果减完之后满足要求再执行秒杀操作，如果库存为零，则标记秒杀商品已经卖完。

在进入到实际秒杀操作后，仍然再次判断库存是否为0，如果为0则返回false。

## 7、页面静态化的过程及什么是浏览器缓存？

将HTML静态页面缓存在客户端浏览器，只有数据通过ajax异步调用接口来获取，仅仅交互的是部分数据，减少了带宽，也加快用户访问的速度。

浏览器缓存就是把一个已经请求过的Web资源（如html页面，图片，js，数据等）拷贝一份副本储存在浏览器中。缓存会根据进来的请求保存输出内容的副本。当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个URL地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。

 ## 8、秒杀架构设计理念？

**限流：** 鉴于只有少部分用户能够秒杀成功，所以要限制大部分流量，只允许少部分流量进入服务后端。

**削峰：**对于秒杀系统瞬时会有大量用户涌入，所以在抢购一开始会有很高的瞬间峰值。高峰值流量是压垮系统很重要的原因，所以如何把瞬间的高流量变成一段时间平稳的流量也是设计秒杀系统很重要的思路。实现削峰的常用的方法有利用缓存和消息中间件等技术。

**异步处理：**秒杀系统是一个高并发系统，采用异步处理模式可以极大地提高系统并发量，其实异步处理就是削峰的一种实现方式。

**内存缓存：**秒杀系统最大的瓶颈一般都是数据库读写，由于数据库读写属于磁盘IO，性能很低，如果能够把部分数据或业务逻辑转移到内存缓存，效率会有极大地提升。

**可拓展：**当然如果我们想支持更多用户，更大的并发，最好就将系统设计成弹性可拓展的，如果流量来了，拓展机器就好了。像淘宝、京东等双十一活动时会增加大量机器应对交易高峰。

## 10、 秒杀系统架构设计思路？

将请求拦截在系统上游，降低下游压力：秒杀系统特点是并发量极大，但实际秒杀成功的请求数量却很少，所以如果不在前端拦截很可能造成数据库读写锁冲突，最终请求超时。

利用缓存：利用缓存可极大提高系统读写速度。

消息队列：消息队列可以削峰，将拦截大量并发请求，这也是一个异步处理过程，后台业务根据自己的处理能力，从消息队列中主动的拉取请求消息进行业务处理。

 ## 11、假如减了库存用户没有支付，库存怎么还原继续参加抢购?

设定一个最长付款时间，比如30分钟，后台有个定时任务（使用定时器Timer），轮询超过30分钟的待付款订单(数据库里面判定订单状态)，然后关闭订单，恢复库存。

